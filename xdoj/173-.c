//0xFFFFFFFFCAFEBABE
/*

问题描述	
请实现一个铁路购票系统的简单座位分配算法，来处理一节车厢的座位分配。
    假设一节车厢有20排、每一排5个座位。为方便起见，我们用1到100来给所有的座位编号，第一排是1到5号，第二排是6到10号，依次类推，第20排是96到100号。
　　购票时，一个人可能购一张或多张票，最多不超过5张。如果这几张票可以安排在同一排编号相邻的座位，则应该安排在编号最小的相邻座位。否则应该安排在编号最小的几个空座位中（不考虑是否相邻）。
假设初始时车票全部未被购买，现在给了一些购票指令，请你处理这些指令，输出购票结果。
例如：若一次购买2，5，4，2张票得到的购票结果为：
    1) 购2张票，得到座位1、2。
    2) 购5张票，得到座位6至10。
    3) 购4张票，得到座位11至14。
    4) 购2张票，得到座位3、4。

输入说明	
输入由两行构成。
第一行包含一个整数n，表示购票指令的数量，1 ≤ n ≤ 100。
第二行包含n个整数，每个整数p在1到5之间，表示要购入的票数，相邻的两个整数之间使用一个空格分隔，所有购票数量之和不超过100。

输出说明	
输出n行，每行对应一条购票指令的处理结果。即对于购票指令p，按从小到大排序输出p张车票的编号。

输入样例	
4
2 5 4 2

输出样例	
1 2
6 7 8 9 10
11 12 13 14
3 4

*/
#include <stdio.h>
#include <math.h>

int main() {
    int n;
    scanf("%d", &n);
    int dp[101] = {0};
    for (int i = 0; i < n; ++i) {
        int t;
        scanf("%d", &t);
        for (int j = 1; j <= 100; ++j) {
            if (dp[j] == 0 && t != 0) {
                //checkAfter
                int cmb = 0;
                for (int k = j; k <= 100; ++k) {
                    if (dp[k] == 0) {
                        cmb++;
                    }
                    if (k % 5 == 0) {
                        break;
                    }
                }
                if (cmb >= t) {
                    for (int k = 0; k < t; ++k) {
                        printf("%d ", k + j);
                        dp[k + j] = 1;
                    }
                    t = 0;
                }
            }
        }

        for (int j = 1; j <= 100; ++j) {
            if (dp[j] == 0 && t != 0) {
                dp[j] = 1;
                t--;
                printf("%d ", j);
            }
        }

        printf("\n");
    }
    return 0;
}